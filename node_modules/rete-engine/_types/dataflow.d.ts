import { NodeEditor, NodeId } from 'rete';
import { ClassicScheme } from './types';
/**
 * DataflowNodeSetup is a set of functions that define how to process a node.
 */
export type DataflowNodeSetup<T extends ClassicScheme['Node'], I extends {
    [key in keyof T['inputs']]: any;
}, O extends {
    [key in keyof T['outputs']]: any;
}> = {
    inputs: () => (keyof I)[];
    outputs: () => (keyof O)[];
    data(fetchInputs: () => Promise<Partial<{
        [key in keyof I]: I[key][];
    }>>): Promise<O> | O;
};
type DefaultInputs = null;
type Inputs = Partial<Record<string, any[]>> | DefaultInputs;
type FetchInputs<T> = T extends DefaultInputs ? Record<string, any> : Partial<T>;
/**
 * Dataflow is a class that allows to process nodes in a graph using Dataflow approach.
 * @priority 8
 */
export declare class Dataflow<Schemes extends ClassicScheme> {
    private editor;
    setups: Map<string, DataflowNodeSetup<any, any, any>>;
    /**
     * @param editor NodeEditor instance
     */
    constructor(editor: NodeEditor<Schemes>);
    /**
     * Adds the node to the dataflow.
     * @param node Node instance
     * @param setup Set of functions that define how to process the node
     */
    add<T extends Schemes['Node']>(node: T, setup: DataflowNodeSetup<T, any, any>): void;
    /**
     * Removes the node from the dataflow.
     * @param nodeId Node id
     */
    remove(nodeId: NodeId): void;
    /**
     * Fetches inputs of the node.
     * Unlike `fetch` method, this method doesn't call `data` function of the specified node (but does call `data` for predecessor nodes recursively).
     * @param nodeId Node id
     * @returns Object with inputs
     */
    fetchInputs<T extends Inputs = DefaultInputs>(nodeId: NodeId): Promise<FetchInputs<T>>;
    /**
     * Fetches outputs of the node.
     * This method recursively calls `data` function of the predecessor nodes until receives all of the required inputs and calls `data` function of the specified node.
     * @param nodeId Node id
     * @returns Object with outputs
     */
    fetch<T extends Record<string, any>>(nodeId: NodeId): Promise<T>;
}
export {};
//# sourceMappingURL=dataflow.d.ts.map