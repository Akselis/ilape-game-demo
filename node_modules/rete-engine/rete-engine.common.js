/*!
* rete-engine v2.1.0
* (c) 2024 Vitaliy Stoliarov
* Released under the MIT license.
* */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _get = require('@babel/runtime/helpers/get');
var _inherits = require('@babel/runtime/helpers/inherits');
var rete = require('rete');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var _typeof = require('@babel/runtime/helpers/typeof');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);

/**
 * ControlFlowNodeSetup is a set of functions that define how to execute a node.
 */

/**
 * ControlFlow is a class that allows to execute nodes in a graph using Control flow approach.
 * @priority 7
 */
var ControlFlow = /*#__PURE__*/function () {
  /**
   * @param editor NodeEditor instance
   */
  function ControlFlow(editor) {
    _classCallCheck__default["default"](this, ControlFlow);
    _defineProperty__default["default"](this, "setups", new Map());
    this.editor = editor;
  }

  /**
   * Adds the node to the control flow.
   * @param node Node instance
   * @param setup Set of functions that define how to execute the node
   */
  return _createClass__default["default"](ControlFlow, [{
    key: "add",
    value: function add(node, setup) {
      var affected = this.setups.get(node.id);
      if (affected) {
        throw new Error('already processed');
      }
      this.setups.set(node.id, setup);
    }

    /**
     * Removes the node from the control flow.
     * @param nodeId Node id
     */
  }, {
    key: "remove",
    value: function remove(nodeId) {
      this.setups["delete"](nodeId);
    }

    /**
     * Execute the node and its successors (in case `forward` is called for some output).
     * @param nodeId Node id
     * @param input Input key that will be considered as the initiator of the execution
     */
  }, {
    key: "execute",
    value: function execute(nodeId, input) {
      var _this = this;
      var setup = this.setups.get(nodeId);
      if (!setup) throw new Error('node is not initialized');
      var inputKeys = setup.inputs();
      if (input && !inputKeys.includes(input)) throw new Error('inputs don\'t have a key');
      setup.execute(input, function (output) {
        var outputKeys = setup.outputs();
        if (!outputKeys.includes(output)) throw new Error('outputs don\'t have a key');
        var cons = _this.editor.getConnections().filter(function (c) {
          return c.source === nodeId && c.sourceOutput === output;
        });
        cons.forEach(function (con) {
          _this.execute(con.target, con.targetInput);
        });
      });
    }
  }]);
}();

function _callSuper$2(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet$1(t, e, o, r) { var p = _get__default["default"](_getPrototypeOf__default["default"](1 & r ? t.prototype : t), e, o); return 2 & r && "function" == typeof p ? function (t) { return p.apply(o, t); } : p; }
/**
 * ControlFlowEngine is a plugin that integrates ControlFlow with NodeEditor making it easy to use
 * @priority 9
 * @listens nodecreated
 * @listens noderemoved
 */
var ControlFlowEngine = /*#__PURE__*/function (_Scope) {
  /**
   * @param configure Allows to specify which inputs and outputs are part of the control flow
   */
  function ControlFlowEngine(configure) {
    var _this;
    _classCallCheck__default["default"](this, ControlFlowEngine);
    _this = _callSuper$2(this, ControlFlowEngine, ['control-flow-engine']);
    _this.configure = configure;
    _this.addPipe(function (context) {
      if (context.type === 'nodecreated') {
        _this.add(context.data);
      }
      if (context.type === 'noderemoved') {
        _this.remove(context.data);
      }
      return context;
    });
    return _this;
  }
  _inherits__default["default"](ControlFlowEngine, _Scope);
  return _createClass__default["default"](ControlFlowEngine, [{
    key: "setParent",
    value: function setParent(scope) {
      _superPropGet$1(ControlFlowEngine, "setParent", this, 3)([scope]);
      this.editor = this.parentScope(rete.NodeEditor);
      this.controlflow = new ControlFlow(this.editor);
    }
  }, {
    key: "add",
    value: function add(node) {
      var options = this.configure ? this.configure(node) : {
        inputs: function inputs() {
          return Object.keys(node.inputs);
        },
        outputs: function outputs() {
          return Object.keys(node.outputs);
        }
      };
      this.controlflow.add(node, {
        inputs: options.inputs,
        outputs: options.outputs,
        execute: function execute(input, forward) {
          node.execute(String(input), forward);
        }
      });
    }
  }, {
    key: "remove",
    value: function remove(node) {
      this.controlflow.remove(node.id);
    }

    /**
     * Trigger execution starting from the specified node.
     * @param nodeId Node id
     * @param input Input key that will be considered as the initiator of the execution
     */
  }, {
    key: "execute",
    value: function execute(nodeId, input) {
      this.controlflow.execute(nodeId, input);
    }
  }]);
}(rete.Scope);

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * DataflowNodeSetup is a set of functions that define how to process a node.
 */

/**
 * Dataflow is a class that allows to process nodes in a graph using Dataflow approach.
 * @priority 8
 */
var Dataflow = /*#__PURE__*/function () {
  /**
   * @param editor NodeEditor instance
   */
  function Dataflow(editor) {
    _classCallCheck__default["default"](this, Dataflow);
    _defineProperty__default["default"](this, "setups", new Map());
    this.editor = editor;
  }

  /**
   * Adds the node to the dataflow.
   * @param node Node instance
   * @param setup Set of functions that define how to process the node
   */
  return _createClass__default["default"](Dataflow, [{
    key: "add",
    value: function add(node, setup) {
      var affected = this.setups.get(node.id);
      if (affected) {
        throw new Error('already processed');
      }
      this.setups.set(node.id, setup);
    }

    /**
     * Removes the node from the dataflow.
     * @param nodeId Node id
     */
  }, {
    key: "remove",
    value: function remove(nodeId) {
      this.setups["delete"](nodeId);
    }

    /**
     * Fetches inputs of the node.
     * Unlike `fetch` method, this method doesn't call `data` function of the specified node (but does call `data` for predecessor nodes recursively).
     * @param nodeId Node id
     * @returns Object with inputs
     */
  }, {
    key: "fetchInputs",
    value: (function () {
      var _fetchInputs = _asyncToGenerator__default["default"](/*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(nodeId) {
        var _this = this;
        var result, inputKeys, cons, inputs, consWithSourceData, _iterator, _step, _step$value, c, sourceData, previous, inputsMutation;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              result = this.setups.get(nodeId);
              if (result) {
                _context2.next = 3;
                break;
              }
              throw new Error('node is not initialized');
            case 3:
              inputKeys = result.inputs();
              cons = this.editor.getConnections().filter(function (c) {
                return c.target === nodeId && inputKeys.includes(c.targetInput);
              });
              inputs = {};
              _context2.next = 8;
              return Promise.all(cons.map(/*#__PURE__*/function () {
                var _ref = _asyncToGenerator__default["default"](/*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(c) {
                  return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        _context.t0 = c;
                        _context.next = 3;
                        return _this.fetch(c.source);
                      case 3:
                        _context.t1 = _context.sent;
                        return _context.abrupt("return", {
                          c: _context.t0,
                          sourceData: _context.t1
                        });
                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee);
                }));
                return function (_x2) {
                  return _ref.apply(this, arguments);
                };
              }()));
            case 8:
              consWithSourceData = _context2.sent;
              _iterator = _createForOfIteratorHelper(consWithSourceData);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  _step$value = _step.value, c = _step$value.c, sourceData = _step$value.sourceData;
                  previous = inputs[c.targetInput] ? inputs[c.targetInput] : [];
                  inputsMutation = inputs;
                  inputsMutation[c.targetInput] = [].concat(_toConsumableArray__default["default"](previous), [sourceData[c.sourceOutput]]);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return _context2.abrupt("return", inputs);
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function fetchInputs(_x) {
        return _fetchInputs.apply(this, arguments);
      }
      return fetchInputs;
    }()
    /**
     * Fetches outputs of the node.
     * This method recursively calls `data` function of the predecessor nodes until receives all of the required inputs and calls `data` function of the specified node.
     * @param nodeId Node id
     * @returns Object with outputs
     */
    )
  }, {
    key: "fetch",
    value: (function () {
      var _fetch = _asyncToGenerator__default["default"](/*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(nodeId) {
        var _this2 = this;
        var result, outputKeys, data, returningKeys;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              result = this.setups.get(nodeId);
              if (result) {
                _context3.next = 3;
                break;
              }
              throw new Error('node is not initialized');
            case 3:
              outputKeys = result.outputs();
              _context3.next = 6;
              return result.data(function () {
                return _this2.fetchInputs(nodeId);
              });
            case 6:
              data = _context3.sent;
              returningKeys = Object.keys(data);
              if (outputKeys.every(function (key) {
                return returningKeys.includes(key);
              })) {
                _context3.next = 10;
                break;
              }
              throw new Error("dataflow node \"".concat(nodeId, "\" doesn't return all of required properties. Expected \"").concat(outputKeys.join('", "'), "\". Got \"").concat(returningKeys.join('", "'), "\""));
            case 10:
              return _context3.abrupt("return", data);
            case 11:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function fetch(_x3) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }())
  }]);
}();

var Cache = /*#__PURE__*/function () {
  function Cache(onDelete) {
    _classCallCheck__default["default"](this, Cache);
    _defineProperty__default["default"](this, "cache", new Map());
    this.onDelete = onDelete;
  }
  return _createClass__default["default"](Cache, [{
    key: "get",
    value: function get(key) {
      return this.cache.get(key);
    }
  }, {
    key: "add",
    value: function add(key, data) {
      if (this.cache.has(key)) throw new Error('cache already exists');
      this.cache.set(key, data);
    }
  }, {
    key: "patch",
    value: function patch(key, data) {
      this.cache.set(key, data);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var item = this.cache.get(key);
      this.cache["delete"](key);
      if (this.onDelete) {
        this.onDelete(item);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this = this;
      Array.from(this.cache.keys()).forEach(function (item) {
        _this["delete"](item);
      });
    }
  }]);
}();

function _callSuper$1(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
/**
 * Cancelled exception. Thrown when `reset` is called while fetching data.
 */
var Cancelled = /*#__PURE__*/function (_Error) {
  function Cancelled() {
    _classCallCheck__default["default"](this, Cancelled);
    return _callSuper$1(this, Cancelled, ['cancelled']);
  }
  _inherits__default["default"](Cancelled, _Error);
  return _createClass__default["default"](Cancelled);
}(/*#__PURE__*/_wrapNativeSuper__default["default"](Error));
function createCancellblePromise() {
  var cancelled = false;
  function commit(value) {
    if (cancelled) {
      throw new Cancelled();
    }
    return value;
  }

  // eslint-disable-next-line init-declarations
  var reject;
  var promise = new Promise(function (res, rej) {
    reject = rej;
    res();
  });
  for (var _len = arguments.length, sequence = new Array(_len), _key = 0; _key < _len; _key++) {
    sequence[_key] = arguments[_key];
  }
  var n = sequence.reduce(function (p, item) {
    var t = p.then(item).then(commit);
    return t;
  }, promise);
  n.cancel = function () {
    if (!cancelled) reject(new Cancelled());
    cancelled = true;
  };
  return n;
}

function _callSuper(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, e, o, r) { var p = _get__default["default"](_getPrototypeOf__default["default"](1 & r ? t.prototype : t), e, o); return 2 & r && "function" == typeof p ? function (t) { return p.apply(o, t); } : p; }
/**
 * DataflowEngine is a plugin that integrates Dataflow with NodeEditor making it easy to use.
 * Additionally, it provides a cache for the data of each node in order to avoid recurring calculations.
 * @priority 10
 * @listens nodecreated
 * @listens noderemoved
 */
var DataflowEngine = /*#__PURE__*/function (_Scope) {
  function DataflowEngine(configure) {
    var _this;
    _classCallCheck__default["default"](this, DataflowEngine);
    _this = _callSuper(this, DataflowEngine, ['dataflow-engine']);
    _defineProperty__default["default"](_this, "cache", new Cache(function (data) {
      return (data === null || data === void 0 ? void 0 : data.cancel) && data.cancel();
    }));
    _this.configure = configure;
    _this.addPipe(function (context) {
      if (context.type === 'nodecreated') {
        _this.add(context.data);
      }
      if (context.type === 'noderemoved') {
        _this.remove(context.data);
      }
      return context;
    });
    return _this;
  }
  _inherits__default["default"](DataflowEngine, _Scope);
  return _createClass__default["default"](DataflowEngine, [{
    key: "setParent",
    value: function setParent(scope) {
      _superPropGet(DataflowEngine, "setParent", this, 3)([scope]);
      this.editor = this.parentScope(rete.NodeEditor);
      this.dataflow = new Dataflow(this.editor);
    }
  }, {
    key: "getDataflow",
    value: function getDataflow() {
      if (!this.dataflow) throw new Error("DataflowEngine isn't attached to NodeEditor");
      return this.dataflow;
    }
  }, {
    key: "add",
    value: function add(node) {
      var _this2 = this;
      var options = this.configure ? this.configure(node) : {
        inputs: function inputs() {
          return Object.keys(node.inputs);
        },
        outputs: function outputs() {
          return Object.keys(node.outputs);
        }
      };
      this.getDataflow().add(node, {
        inputs: options.inputs,
        outputs: options.outputs,
        data: function () {
          var _data = _asyncToGenerator__default["default"](/*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(fetchInputs) {
            var cache, cancellable;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  cache = _this2.cache.get(node.id);
                  if (!cache) {
                    _context.next = 3;
                    break;
                  }
                  return _context.abrupt("return", cache);
                case 3:
                  cancellable = createCancellblePromise(function () {
                    return fetchInputs();
                  }, function (inputs) {
                    return node.data(inputs);
                  });
                  _this2.cache.add(node.id, cancellable);
                  return _context.abrupt("return", cancellable);
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function data(_x) {
            return _data.apply(this, arguments);
          }
          return data;
        }()
      });
    }
  }, {
    key: "remove",
    value: function remove(node) {
      this.getDataflow().remove(node.id);
    }

    /**
     * Resets the cache of the node and all its predecessors.
     * @param nodeId Node id to reset. If not specified, all nodes will be reset.
     */
  }, {
    key: "reset",
    value: function reset(nodeId) {
      var _this3 = this;
      if (nodeId) {
        var setup = this.getDataflow().setups.get(nodeId);
        if (!setup) throw new Error('setup');
        var outputKeys = setup.outputs();
        this.cache["delete"](nodeId);
        this.editor.getConnections().filter(function (c) {
          return c.source === nodeId && outputKeys.includes(c.sourceOutput);
        }).forEach(function (c) {
          _this3.reset(c.target);
        });
      } else {
        this.cache.clear();
      }
    }

    /**
     * Fetches input data for the node by fetching data for all its predecessors recursively.
     * @param nodeId Node id to fetch input data for
     * @throws `Cancelled when `reset` is called while fetching data
     */
  }, {
    key: "fetchInputs",
    value: (function () {
      var _fetchInputs = _asyncToGenerator__default["default"](/*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(node) {
        var id;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              id = _typeof__default["default"](node) === 'object' ? node.id : node;
              return _context2.abrupt("return", this.getDataflow().fetchInputs(id));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function fetchInputs(_x2) {
        return _fetchInputs.apply(this, arguments);
      }
      return fetchInputs;
    }()
    /**
     * Fetches output data of the node
     * @param nodeId Node id to fetch data from
     * @throws `Cancelled` when `reset` is called while fetching data
     */
    )
  }, {
    key: "fetch",
    value: (function () {
      var _fetch = _asyncToGenerator__default["default"](/*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(node) {
        var id;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              id = _typeof__default["default"](node) === 'object' ? node.id : node;
              return _context3.abrupt("return", this.getDataflow().fetch(id));
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function fetch(_x3) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }())
  }]);
}(rete.Scope);

exports.Cancelled = Cancelled;
exports.ControlFlow = ControlFlow;
exports.ControlFlowEngine = ControlFlowEngine;
exports.Dataflow = Dataflow;
exports.DataflowEngine = DataflowEngine;
exports.createCancellblePromise = createCancellblePromise;
//# sourceMappingURL=rete-engine.common.js.map
